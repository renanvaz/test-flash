  package {	import flash.display.MovieClip;	import flash.media.Microphone;	import flash.system.Security;	import flash.events.ActivityEvent;    import flash.events.SampleDataEvent;    import flash.utils.ByteArray;    import flash.media.SoundMixer;    import flash.display.Graphics;	public class Test extends MovieClip {        public const SAMPLING_RATE:int  = 44100;        public const SAMPLES:int        = 1024 / 2;        public const CHANNEL_LENGTH:int = SAMPLES;        public const REPEAT:int         = 3;        public const OFFSET:int         = 60;        public const PLOT_HEIGHT:int    = stage.stageHeight/2;        public var left:Array           = [];        public var right:Array          = [];        public var last:int             = 0;        public var start:Boolean        = false;        private var mic: Microphone;		public function Test(): void        {            mic = Microphone.getMicrophone();            mic.framesPerPacket = 2; // Default 2            mic.rate = 44; // 44100Hz, Default 8            mic.setLoopBack(true);            mic.setSilenceLevel(1, 0);            mic.setUseEchoSuppression(false);            mic.addEventListener(SampleDataEvent.SAMPLE_DATA, onSampleData);            /*var first = "A", last = "z";            for(var i = first.charCodeAt(0); i <= last.charCodeAt(0); i++) {                trace(hzToAscii(charToAscii(String.fromCharCode(i))));            }*/		}        private function onSampleData (event:SampleDataEvent): void        {            var hz:int = 0;            var bytes = event.data;            var g:Graphics = this.graphics;            var current:int = 0;            for (var i:int = 0; i < 2048; i++) {                current = bytes.readFloat() > 0 ? 1 : 0;                if (current != last) {                    last = current;                    hz++;                }            }            hz = Math.round(hz/2);            trace(String.fromCharCode(this.hzToAscii(hz)));            /*g.clear();            g.lineStyle(0, 0x6600CC);            g.beginFill(0x6600CC);            g.moveTo(0, PLOT_HEIGHT);            var n:Number = 0;            // left channel            for (var i:int = 0; i < CHANNEL_LENGTH; i++) {                n = (bytes.readFloat() * PLOT_HEIGHT);                g.lineTo((i / CHANNEL_LENGTH) * stage.stageWidth, PLOT_HEIGHT - n);            }            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);            g.endFill();            // right channel            g.lineStyle(0, 0xCC0066);            g.beginFill(0xCC0066, 0.5);            g.moveTo(0, PLOT_HEIGHT);            for (i = 0; i < CHANNEL_LENGTH; i++) {                n = (bytes.readFloat() * PLOT_HEIGHT);                g.lineTo((i / CHANNEL_LENGTH) * stage.stageWidth, PLOT_HEIGHT - n);            }            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);            g.endFill();*/        }        public function charToAscii(c): int        {            return Math.round(((c.charCodeAt(0) - 45) *1) * 44100/2048);        }        public function hzToAscii(h): int        {            return Math.round(h + 45);        }	}}